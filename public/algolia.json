[{"categories":null,"content":"技术栈 iOS开发 Mac开发 小程序开发 Flutter开发 ","date":"2023-07-14","objectID":"/about/:1:0","tags":null,"title":"个人介绍","uri":"/about/"},{"categories":["iOS开发"],"content":"一直以来对数值大小进行约束都是在textField的代理里面进行的，在输入过程中或者输入结束的代理里面，对输入的值进行判定和修改。最近发现了更优雅的做法，就是使用Property Wrapper封装约束逻辑，在set方法里面对值进行赋值的时候就对值进行修改。 ","date":"2023-05-16","objectID":"/posts/property-wrapper-value-limit/:0:0","tags":["swift","iOS","Property Wrapper"],"title":"使用Property Wrapper进行数值约束","uri":"/posts/property-wrapper-value-limit/"},{"categories":["iOS开发"],"content":"Property Wrapper使用方法 对于Property Wrapper类型，必须： 使用@propertyWrapper进行定义 必须有wrappedValue属性 @propertyWrapper struct Wrapper\u003cT\u003e { var wrappedValue: T } 这时候我们就可以通过@Wrapper修饰一个属性，这个属性绑定的就是wrappedValue。 @Wrapper var x = 0 ","date":"2023-05-16","objectID":"/posts/property-wrapper-value-limit/:1:0","tags":["swift","iOS","Property Wrapper"],"title":"使用Property Wrapper进行数值约束","uri":"/posts/property-wrapper-value-limit/"},{"categories":["iOS开发"],"content":"构建 我们要实现这样的功能：如果一个数值在一个区间内，就返回这个数值本身，如果小于这个区间，就返回这个区间的最小值，如果大于这个区间，就返回这个区间的最大值。 这个思路可以通过Swift.max(Swift.min(self, maxValue), minValue)来实现。 可以比较的类型都是Comparable类型的，所以我们创建一个协议并添加默认实现： protocol FPValueLimit: Comparable { func limit(from minValue: Self, to maxValue: Self) -\u003e Self } extension FPValueLimit { func limit(from minValue: Self, to maxValue: Self) -\u003e Self { Swift.max(Swift.min(self, maxValue), minValue) } } 并为常用的数值类型添加此协议： extension Int: FPValueLimit {} extension Int8: FPValueLimit {} extension Int16: FPValueLimit {} extension Int32: FPValueLimit {} extension Int64: FPValueLimit {} extension Float: FPValueLimit {} extension Double: FPValueLimit {} 这时候，其实这些类型已经可以通过limit(from: minValue, to: maxValue)方法实现了数值约束了。但是这不是最终目的。 添加Property Wrapper类型ValueLimit: /// 限制一个值在一个固定的区间 /// 如果超过这个区间，则取这个值的最大/最小值 @propertyWrapper struct ValueLimit\u003cT\u003e where T: FPValueLimit { private var value: T? var minValue: T var maxValue: T var wrappedValue: T? { get { value } set { guard let aValue = newValue else { return } value = aValue.limit(from: minValue, to: maxValue) } } init(min: T, max:T) { self.minValue = min self.maxValue = max } } 通过在wrappedValue的set方法，我们可以为添加这个前缀的属性在set的时候添加数值约束。 比如在填单的时候填写重量： @ValueLimit(min: FPRule.minWeight, max:FPRule.maxWeight) var weight: Int? { didSet { guard let weight = weight, weight \u003e 0 else { return } weightTextField.stringValue = weight.format.toWeightDisplay() } } 在didSet方法执行的时候，赋值的weight已经经过了数值约束，在最大和最小值之中了。在UI控件textField还没有碰到数值之前，数值就已经做好了一切准备。 有时候数值限制还需要添加警示信息： /// 如果一个值超出固定的区间，弹出警告信息 @propertyWrapper struct ValueLimitAlert\u003cT\u003e where T: Comparable { private var value: T? var minValue: T var maxValue: T var alertMessage: String var wrappedValue: T? { get { value } set { guard let newValue = newValue else { return } if newValue \u003e maxValue || newValue \u003c minValue { FPHUD.shared.showToast(text: alertMessage) } } } init(min: T, max:T, alert: String) { self.minValue = min self.maxValue = max self.alertMessage = alert } } 这样在超出范围的时候，就会弹出对应的警示信息了。 ","date":"2023-05-16","objectID":"/posts/property-wrapper-value-limit/:2:0","tags":["swift","iOS","Property Wrapper"],"title":"使用Property Wrapper进行数值约束","uri":"/posts/property-wrapper-value-limit/"},{"categories":["iOS开发"],"content":"目的 简化保存UserDefaults的写法，通过正常属性赋值取值的方式进行UserDefaults的存取。 比如，正常，保存和读取UserDefaults是这样的： UserDefaults.standard.setValue(\"aaa\", forKey: \"stringvalue\") UserDefaults.standard.value(forKey: \"stringvalue\") as? String 如果我想要这样做呢？ // 保存到UserDefaults中 UserDefaults.stringValue = \"aaa\" // 从UserDefaults中读取 print(UserDefaults.stringValue) ","date":"2023-03-11","objectID":"/posts/property-wrapper-userdefaluts/:1:0","tags":["swift","iOS","Property Wrapper"],"title":"Property Wrapper优化UserDefaults的使用","uri":"/posts/property-wrapper-userdefaluts/"},{"categories":["iOS开发"],"content":"定义要存取的值 属性保存为UserDefaults的类属性，如： extension UserDefaults { static var boolValue: Bool? static var stringValue: String? static var dictValue: [String: String]? static var dateValue: Date? } 这样的赋值方式只是保存在了内存里面，接下来要使用Property Wrapper在进行存取的时候额外做点事情，把值保存和读取在UserDefaults里面。 ","date":"2023-03-11","objectID":"/posts/property-wrapper-userdefaluts/:2:0","tags":["swift","iOS","Property Wrapper"],"title":"Property Wrapper优化UserDefaults的使用","uri":"/posts/property-wrapper-userdefaluts/"},{"categories":["iOS开发"],"content":"定义Property Wrapper // 最基本的结构 @propertyWrapper struct UserDefault\u003cValue\u003e { var wrappedValue: Value } 现在为wrappedValue设置get和set方法，在这里面进行UserDefaults的存取。 因为取值的时候并不能保证一定能取到，所以要设置一个默认值，在无法取到值的时候使用默认值替代。 @propertyWrapper struct UserDefault\u003cValue\u003e { let key: String // 默认值 let defaultValue: Value var wrappedValue: Value { get { // 在无法从UserDefaults里面取到值的时候，就取默认值 return UserDefaults.standard.object(forKey: key) as? Value ?? defaultValue } set { UserDefaults.standard.set(newValue, forKey: key) } } } 为特定属性添加存取特性 extension UserDefaults { @UserDefault(key: \"boolvalue\", defaultValue: false) static var boolValue: Bool @UserDefault(key: \"stingvalue\", defaultValue: \"default\") static var stringValue: String @UserDefault(key: \"dictvalue\", defaultValue: [String: String]()) static var dictValue: [String: String] @UserDefault(key: \"datevalue\", defaultValue: Date()) static var dateValue: Date } 之所以把可选值的\"?“去掉，是因为UserDefaults.standard.object(forKey: key) as? Value当Value为可选值的时候，即使前面的值为nil，也不会走后面的?? defaultValue了。 ","date":"2023-03-11","objectID":"/posts/property-wrapper-userdefaluts/:3:0","tags":["swift","iOS","Property Wrapper"],"title":"Property Wrapper优化UserDefaults的使用","uri":"/posts/property-wrapper-userdefaluts/"},{"categories":["iOS开发"],"content":"添加对nil的支持 如果想要在设置一个属性为nil的时候，不需要设置默认值，那就要添加一个新的初始化方法，在Value为可选值的时候，可以使用该初始化方法。 判断Value是否是可选值可以判断该Value是否遵从ExpressibleByNilLiteral协议。 extension UserDefault where Value: ExpressibleByNilLiteral { init(key: String) { self.init(key: key, defaultValue: nil) } } 当Value值为可选值的时候，就可以不传默认值了。 当传nil的时候，删除UserDefaults中的key，可以在set中判断newValue是否为nil。我们先设置一个protocol： protocol AnyOptional { var isNil: Bool { get } } extension Optional: AnyOptional { var isNil: Bool { self == nil } } 此时就可以用AnyOptional来判断是否是nil了： @propertyWrapper struct UserDefault\u003cValue\u003e { let key: String let defaultValue: Value var wrappedValue: Value { get { return UserDefaults.standard.object(forKey: key) as? Value ?? defaultValue } set { if let optionalValue = newValue as? AnyOptional, optionalValue.isNil { UserDefaults.standard.removeObject(forKey: key) } else { UserDefaults.standard.set(newValue, forKey: key) } } } } 此时，我们的属性设置可以为可选值： extension UserDefaults { @UserDefault(key: \"boolvalue\", defaultValue: false) static var boolValue: Bool @UserDefault(key: \"stingvalue\", defaultValue: \"default\") static var stringValue: String // 不需要传默认值 @UserDefault(key: \"dictvalue\") static var dictValue: [String: String]? @UserDefault(key: \"datevalue\", defaultValue: Date()) static var dateValue: Date } ","date":"2023-03-11","objectID":"/posts/property-wrapper-userdefaluts/:4:0","tags":["swift","iOS","Property Wrapper"],"title":"Property Wrapper优化UserDefaults的使用","uri":"/posts/property-wrapper-userdefaluts/"},{"categories":["iOS开发"],"content":"添加对自定义模型的支持 UserDefaults不支持class、struct等的类型的保存，需要先进行序列化/反序列化才能进行正常读取。所以，针对这样的情况，对这些非基本类型的保存，就使用另外的Property Wrapper进行单独处理。 比如，一个Person类的保存： extension UserDefaults { @UserDefault(key: \"personvalue\", defaultValue: Person(name: nil, age: nil)) static var personValue: Person } class Person { var name: String? var age: Int? init(name: String?, age: Int?) { self.name = name self.age = age } } let person: Person = Person(name: \"Ivan\", age: 30) UserDefaults.personValue = person // Wrong！！！ 以上操作会导致报错。所以我们需要进行额外的操作： @propertyWrapper struct UserDefaultCodable\u003cValue: Codable\u003e { let key: String let defaultValue: Value var container: UserDefaults = .standard var wrappedValue: Value { get { if let data = container.object(forKey: key) as? Data, let user = try? JSONDecoder().decode(Value.self, from: data) { return user } return defaultValue } set { if let encoded = try? JSONEncoder().encode(newValue) { container.set(encoded, forKey: key) } } } } 使该类支持Codable： class Person: Codable { var name: String? var age: Int? init(name: String?, age: Int?) { self.name = name self.age = age } } 这时候，就可以对非基础类型进行正常的存取了。 ","date":"2023-03-11","objectID":"/posts/property-wrapper-userdefaluts/:5:0","tags":["swift","iOS","Property Wrapper"],"title":"Property Wrapper优化UserDefaults的使用","uri":"/posts/property-wrapper-userdefaluts/"},{"categories":["小程序开发"],"content":"一直以来开发小程序都是中规中矩的使用微信小程序开发工具，原生开发小程序。最近偶然发现了一个腾讯出品的小程序开发框架WePY，是对小程序做了进一步的封装，看起来亮点多多。 ","date":"2019-03-28","objectID":"/posts/wepy-miniapp/:0:0","tags":["小程序","wepy"],"title":"使用WePY进行小程序开发","uri":"/posts/wepy-miniapp/"},{"categories":["小程序开发"],"content":"优势 使用类似于目前最为火爆的前端框架Vue.js的开发风格，前端开发者可以轻松掌握 支持使用第三方的NPM资源，可使用的组件更为丰富 支持最新的JS语法，支持ES6、ES7的若干新特性 单文件模式，不再像原生小程序那样一个页面需要四个文件 WePY的优势还在于相比其他类似的小程序开发框架，它的开源时间较早，有极其丰富的组件库，也有很多的Demo可供参考，比如微信小程序wepy框架开发资源汇总。 ","date":"2019-03-28","objectID":"/posts/wepy-miniapp/:1:0","tags":["小程序","wepy"],"title":"使用WePY进行小程序开发","uri":"/posts/wepy-miniapp/"},{"categories":["小程序开发"],"content":"开始安装 全局安装WePY命令行工具wepy-cli，如果有权限问题请在前面加上sudo。 npm install wepy-cli -g 使用wepy init创建WePY项目。 // 使用空模板创建 wepy init empyt myproject // 使用基础模板创建 wepy init standard myproject // 使用其他GitHub上的demo wepy init wepyjs/wepy-wechat-demo myproject 在项目目录下安装依赖 cd myproject npm install 运行项目 // 测试(该命令下会运行 wepy build --watch) npm run dev // 正式(项目包会减小,该命令下会运行 cross-env NODE_ENV=production wepy build --no-cache) npm run build 执行上面的命令后，再项目根目录会生成一个叫做dist的文件夹，用微信开发者工具打开这个目录，里面就是典型的小程序架构的项目了。 编译小程序项目前记得要把一些设置关掉，如关闭ES6转ES5选项，关闭代码样式自动补全选项，关闭代码压缩上传选项，开启不检查域名选项。 ","date":"2019-03-28","objectID":"/posts/wepy-miniapp/:2:0","tags":["小程序","wepy"],"title":"使用WePY进行小程序开发","uri":"/posts/wepy-miniapp/"},{"categories":["小程序开发"],"content":"IDE配置 在IDE方面我使用的口碑较好的WebStorm来进行WePY开发。默认情况下WebStorm是不识别WePY类型的文件的，为了使其实现对wpy文件的渲染，如下图所示，打开WebStorm的偏好设置，在Vue.js的Template里面添加wpy后缀的识别。 另外也推荐使用VS Code去进行WePY开发，VS Code是目前最流行的代码编辑器之一，有很丰富的插件扩展，比如Vetur-wepy插件就直接对wpy文件进行了正确的渲染，minapp插件对小程序的标签、属性进行了正确的补全等等。如果喜欢轻量级编辑器的朋友可以选择这款只有几十M的VS Code。 ","date":"2019-03-28","objectID":"/posts/wepy-miniapp/:3:0","tags":["小程序","wepy"],"title":"使用WePY进行小程序开发","uri":"/posts/wepy-miniapp/"},{"categories":["小程序开发"],"content":"相关文件配置 package.json scripts: WePY项目可执行的npm scripts,默认有dev, build, test三个命令，可以通过npm run dev/build/test来执行。比如npm run dev默认情况下就是执行的wepy build --watch命令，npm run build就是执行的cross-env NODE_ENV=production wepy build --no-cache命令。 建议把dev命令改为cross-env NODE_ENV=development wepy build --watch，这样在使用npm run dev或者npm run build时，在wepy.config.js中可以通过process.env.NODE_ENV拿到不同的环境变量值。 dependencies: 项目所依赖的模块 devDependencies: 只下载使用某些模块，而不下载这些模块的测试和文档框架 package-lock.json 所有node_modules里面的模块的版本、地址、依赖等相关信息。它和package.json的关系就类似于iOS项目里面podfile和podfile.lock文件的关系。 project.config.json setting: 对应标准小程序项目里面的project.config.json文件里面的setting设置。es6为是否开启es6转es5，postcss为上传代码时是否自动代码补全，minified为上传代码时是否代码压缩，urlCheck为是否检查安全域名和TLS版本。 miniprogramRoot: 编译的微信小程序项目所在目录，默认为\"./dist\"。 wepy.config.js wpyExt: WePY文件的后缀名，默认为.wpy，如果改为.vue，同样能解决页面文件代码高亮的问题。 compilers: 支持sass, less, postcss, babel, stylus, typescript语法的使用。 ","date":"2019-03-28","objectID":"/posts/wepy-miniapp/:4:0","tags":["小程序","wepy"],"title":"使用WePY进行小程序开发","uri":"/posts/wepy-miniapp/"},{"categories":["iOS开发"],"content":"看过不少分析Swift解决循环引用的文章，分析weak和unowned的区别等等，可能是不太符合我的思路，一直感觉很模糊，在平时使用的时候对什么时候用weak，什么时候用unowned方面还是不太明确，干脆自己在这方面进行了一次整理。 ","date":"2017-10-13","objectID":"/posts/swift-cyc-ref/:0:0","tags":["iOS","swift","循环引用"],"title":"浅明分析Swift循环引用","uri":"/posts/swift-cyc-ref/"},{"categories":["iOS开发"],"content":"自动引用计数（ARC） Swift和OC一样，使用的是自动引用计数的机制来追踪和管理APP的内存。顾名思义，自动引用计数是自动进行的，并不需要我们手动去参与内存的管理——当一个实例使用完了的时候，会自动对其占用的内存进行释放。当然，ARC管理的只是引用类型，值类型的（比如结构体和枚举）不在其管理范围之内。 ARC其实就干了三件事： 为新创建的实例分配内存 确保使用中的实例不会被销毁 确保使用完的实例被正确释放，腾出占用的内存空间 上面三板斧的实现是靠ARC维护一个计数来实现的，当初始化的时候，引用计数为1；每次有新的对这个实例的引用的时候，引用计数加1；每次对应引用被置为nil时，引用计数减1；当引用计数为0的时候，该实例被销毁，回收内存空间。 举个例子吧，假如有一个类如下： class Person { let name: String init(name: String) { self.name = name } deinit { print(\"\\(name)被注销了\") } } 这个类很简单，一个name的属性，一个构造函数，一个析构函数。创建该类的新实例的时候，调用构造函数，销毁该实例的时候，调用析构函数。 下面，我们创建一个Person类的实例，如下 Person.init(name: \"Ivan\") 我们只是创建了这个实例，在正常使用中我们是不会单纯这样做的，没有意义。我们会把这个实例赋值给某个变量来进行使用。 let person1 = Person.init(name: \"Ivan\") // 引用计数加1，现在为1 这时候，person1和这个Person类的新实例直接建立了一个强引用，该实例的引用计数加1。也是因为该实例有强引用，所以它所在的内存空间不会被销毁，在ARC眼中它还有利用价值。 假如这个实例也赋值给了其他变量，如下 let person2 = person1 // 引用计数加1，现在为2 let person3 = person1 // 引用计数加1，现在为3 let person4 = Person.init(name: \"Jack\") // 引用计数加1，这是个新的实例，这个实例引用计数现在为1 当变量对这个实例的引用被销毁，即置为nil的时候，就会减少这个实例的引用计数，当引用计数为0 的是，这个实例即被销毁，回收内存空间。 person1 = nil // 引用计数减1，现在为2 person2 = nil // 引用计数减1，现在为1 person3 = nil // 引用计数减1，现在Person类的这个实例被销毁了 但是ARC毕竟不是智能的，默认它会把所有的引用归为强引用，只要还在被其他的属性、常量、变量所使用，它是不会被释放的。但是凡事总有特殊情况，这时候就需要对ARC释放内存的方式进行提示（weak，unowned）。 ","date":"2017-10-13","objectID":"/posts/swift-cyc-ref/:0:1","tags":["iOS","swift","循环引用"],"title":"浅明分析Swift循环引用","uri":"/posts/swift-cyc-ref/"},{"categories":["iOS开发"],"content":"循环引用 墨菲定律：如果事情有变坏的可能，不管这种可能性有多小，它总会发生。 我们再举一个例子，有下面2个相关类： class Person { let name: String var pet: Dog? init(name: String) { self.name = name } deinit { print(\"\\(name)被注销了\") } } class Dog { let nickName: String let owner: Person? init(species: String) { self.species = species } deinit { print(\"\\(nickName)被注销了\") } } 发现Person类多了一个Dog属性，Dog类里面也有一个Person属性。一个人可以拥有一只宠物狗，一只狗也可以拥有一个主人；同时因为一个人也可以没有宠物，一只狗也可以是一只野狗，所以这两个变量都是可选的。 那么问题来了：假如我们同时创建了这两个类的实例并且赋值给了两个变量会怎么样？ var ivan = Person.init(name: \"ivan\") var wawa = Dog.init(nickName: \"wawa\") 就像上图一样，ivan变量建立了对Person实例的强引用，wawa建立了对Dog实例的强引用。其实没什么，因为两者并没有什么关系。但是，如果我们加上下面的语句： ivan.pet = wawa wawa.owner = ivan 那么一切都不一样了，如下图： 此时在之前两个强引用的基础上，多了Person实例中的pet变量对Dog实例的强引用，以及Dog实例的owner变量对Person实例的强引用。 如果这时候，我们结束了对这两个实例的使用，想要销毁它们来腾出内存空间，这时候就出问题了。 ivan = nil wawa = nil 如上图，我们的变量到实例直接的引用已经没有了，但是这两个实例会被销毁吗？答案是否定的。因为他们直接还相互存在引用，只要还有对实例的引用，那么实例就不会轻易被销毁，内存空间也不会被正确释放，这就是因为循环引用导致的内存泄漏。 ","date":"2017-10-13","objectID":"/posts/swift-cyc-ref/:0:2","tags":["iOS","swift","循环引用"],"title":"浅明分析Swift循环引用","uri":"/posts/swift-cyc-ref/"},{"categories":["iOS开发"],"content":"解决循环引用导致的内存泄漏问题 从上面的例子里面可以看到，存在一种可能，ARC会维护一种永远不会置为0的实例：如果两个实例互相持有对方的强引用，那么会互相让对方永远至少存在1的引用计数，这就造成了循环强引用。 首先，我们在平时的类关系设计的时候就会事先考虑好，尽量去避免对象实例之间的相互持有，也就避免了循环引用。 当然，在设计上无法避免这样的设定的时候，就可以对类关系之间的关系进行重新定义，把强引用改为弱引用或者无主引用。弱引用和无主引用允许发生了循环引用的两个实例之间的一个实例引用另外一个实例而不保持强引用。 那么在什么时候用弱引用，什么时候用无主引用呢？ 在两个实例中，假如一个实例引用的另外一个实例具有更短的生命周期，那么就使用弱引用(weak)来引用这个实例，如果引用的实例具有相同的或者更长的生命周期的时候，那么就使用无主引用(unowned)。 这两个在使用的时候一定要注意，假如你使用了无主引用引用了一个实例，你必须保证这个实例在引用者的生命周期内不会被销毁，如果被引用的这个实例却先一步over了，你依然访问这个无主引用，那么就会导致崩溃。弱引用不会对其引用的实例保持强引用，也就不会去阻止ARC销毁被引用的实例。 那么，如何去保证无主引用的实例不会被销毁呢？一般来说，引用的这个实例是永远存在的，不可能为nil。所以，我们可以这样区分：两个循环引用的实例所引用的属性都允许为nil的时候，可以使用弱引用来解决；但是如果其中一个属性的值不允许为nil的时候,即只要这个实例存在，就一定会引用着另外一个实例的属性，那么就可以使用无主引用来解决了。 假如出现了这种情况：两个实例所引用的属性都不允许为nil，互相引用该怎么破？假如有两个类，一个是国家Country，一个是城市City。城市肯定属于一个国家，一个国家也肯定会有一个首都城市。这就是互相引用了不为nil的属性。 如下所示： class Country { let name: String var capitalCity: City! init(name: String, capitalName: String) { self.name = name self.capitalCity = City(name: capitalName, country: self) } } class City { let name: String unowned let country: Country init(name: String, country: Country) { self.name = name self.country = country } } 我们可以看到在Country类里面有个capitalCity属性，在City类里面有个country属性。同时，在County类的构造器里面有对City的初始化赋值到自己的capitalCity属性，在对City初始化的这个构造器里面有一个country参数引用了Country实例(self)。 构造过程没有进行完的时候如何使用这个类的实例呢？这里使用了swift两段式构造的特性，第一段构造，给每一个存储型属性指定一个初始值；第二段构造才会对属性进行进一步定制。Country类里面的capitalCity类型设置为隐式解析可选类型，City！表示这个可选类型属性初始化的值为nil，但是不需要进行展开。因为有初始值nil，所以顺利度过第一段构造，在name属性也被构造器赋值后，其实所有属性就已经初始化完成，这个类已经构造完成，所以在第二段构造过程中可以使用self作为参数，为capitalCity进行重新赋值。 通过这种方式我们可以通过一条语句同时创建Country类和City类的实例，这样就不会产生循环引用。在这里，我们一边使用了无主引用，一边使用了隐式解析，通过二段式构造的特性巧妙解决了相互引用的问题。 闭包中的循环引用 因为闭包也是引用类型，所以闭包也和一个类一样，如果一个类的某个属性引用了闭包，而这个闭包中又引用了这个类实例，那么就会出现闭包引起的循环引用问题。 swift很人性化的一点就是，假如你在闭包里面是用了这类实例的某个属性或者某个方法，就一定会提示你在前面加上self，以提醒你注意循环引用被你一不小心就制造了出来。 swift维护有一个闭包捕获列表，列表的每一项都是由中括号括起来的一对值组成，第一个值是weak或者unowned，另外一个值是对类实例的引用或者是初始化后的变量，比如[unowned self], [weak delegate = self.delegate]等。 当闭包和它捕获的实例相互引用并且是同时销毁的时候，将闭包里面捕获的引用定义为无主引用。如果被捕获的引用可能会变为nil的时候，将它定义为弱引用。 ","date":"2017-10-13","objectID":"/posts/swift-cyc-ref/:0:3","tags":["iOS","swift","循环引用"],"title":"浅明分析Swift循环引用","uri":"/posts/swift-cyc-ref/"},{"categories":["IT杂文"],"content":" MacBook使用时间长了之后难免会有很多杂七杂八的文件，存储空间严重不足，我一狠心，就趁着升级到10.12(macOS Sierra)系统的机会，把MacBook直接全部抹掉重装了。重装还不算麻烦，但是麻烦的就是在一清二白的系统上重新搭建起各种环境…… ","date":"2016-10-14","objectID":"/posts/mac-resetup/:0:0","tags":["Mac","小技巧"],"title":"Mac重装+初始化配置","uri":"/posts/mac-resetup/"},{"categories":["IT杂文"],"content":"一、重装系统 据我所知的重装Mac系统的方法有三种： 通过Time Machine恢复 在线重装 自制U盘重装 具体的操作方式可以在网上查，本人懒一点，再加上网速还可以，就用了最省事的在线重装。 关闭MacBook，然后按住Commend + R不放，打开电源，直到出现苹果的标志，然后放开Commend + R。 这时候进入了OS X实用工具的界面，分别有“从Time Machine备份进行恢复“、”更新安装OS X“、”获得在线帮助“、”磁盘工具“这四类。 先进入”磁盘工具“，这时候左边能看到两个盘。上面的一个盘是自己的主存储盘，下属一个Macintosh HD子盘；下面的一个大概有2G左右的盘，就是类似于Windows PE系统的一个空间，不要去动它。选择Macintosh HD子盘，抹掉。 返回进入”更新安装OS X“选项，选择Macintosh HD子盘，进行在线安装。我安装的时候显示还有5分钟，可是我足足用了半个多小时才把这5分钟给跑完(吐槽一下苹果弱智的时间算法)……然后就自动进行系统安装了。 剩下的就是配置Apple ID，以便于以后还原数据。 ","date":"2016-10-14","objectID":"/posts/mac-resetup/:1:0","tags":["Mac","小技巧"],"title":"Mac重装+初始化配置","uri":"/posts/mac-resetup/"},{"categories":["IT杂文"],"content":"二、配置系统 首先我就安装了Xcode，吃饭的家伙，必须要先保证有。然后安装了搜狗输入法、Clean My Mac、 有道词典、腾讯QQ、 为知笔记、 网易云音乐、 Dash、 Source Tree、 iStat Menus、 Snip、 The Unarchiver、 XMind这几个软件，其他的以后想起来再安装。 值得注意的一点是，有些软件从App Store下载和从官方网站下载是完全不同的，App Store会对某些功能进行限制。比如；有道词典的划词和屏幕取词功能、网易云音乐的支持键盘顶部音乐控制功能，Snip的滚动截屏功能等。 升级ruby 从网上看到有因为ruby版本低而安装Cocoapods失败的，所以本着谨慎的原则，要先更新ruby。 更新ruby需要安装RVM，所以要先安装RVM。 curl -L https://get.rvm.io | bash -s stable 指定位置 source ~/.rvm/scripts/rvm 然后通过命令 rvm -v 查到我的RVM版本是1.27.0。 3. 通过命令 ruby -v 查到我的ruby版本是2.0.0p648。 然后通过命令 rvm list known 查到最新的版本是2.3.0。 通过命令 rvm install 2.3.0 来安装在最新版本的ruby，但是它提示你没有安装Homebrew,输入路径进行安装，按回车键选择默认位置，然后一路回车，安装brew完毕，然后终端自动继续安装ruby 2.3.0，安装成功。 安装Cocoapods 通过命令 gem sources -l 查到系统默认的gem的源是https://rubygems.org/ ，这个在国内有被墙的危险，所以要改为国内的淘宝源。因为近期淘宝的ruby镜像网站已经放弃维护，RubyGems 镜像的管理工作以后将交由 [Ruby China](https://gems.ruby-china.com/) 负责，所以之前的淘宝镜像已经不能使用了。同时，Ruby China的镜像网址也由https://gems.ruby-china.org/替换为https://gems.ruby-china.com/，请大家注意及时更改！ gem sources --remove https://rubygems.org/ gem sources -a https://gems.ruby-china.com/ 然后对gem进行更新 sudo gem update --system 更新后的版本为2.6.6。 2. 终于到了要安装Cocoapods的时候了，由于Cocoapods的库文件太大，下载时间太长，可以从一台已经下载好了的电脑的~/目录里面把.cocoapods/文件夹拷贝到对应的位置，然后再下载库文件就省很多时间。 但是系统默认是看不到隐藏文件夹的，可以通过命令 defaults write com.apple.finder AppleShowAllFiles -bool true 来使隐藏文件失效，必须重启finer才能生效。 6. 通过命令 sudo gem install cocoapods 安装Cocoapods。 把从其它电脑复制得来的.cocoapods文件放到~/路径里面，然后终端运行 pod setup 在很短的时间内就安装好了。 安装LLDB命令插件chisel 在控制台输入以下命令 brew install chisel 根据提示，在~/路径查找.lldbinit文件，发现没有，就新建一个该文件，并插入提示的文字。 cd ~ touch .lldbinit vi .lldbinit 在文件中粘贴 command script import /usr/local/opt/chisel/libexec/fblldb.py 这段话，并进行保存。 Safari插件配置 点击左上角Safari按钮 -\u003e Safari扩展… ，进入了一个插件库。先安装了Evernote Web Clipper，它可以很方便地把网页中的内容保存到自己的印象笔记账户里面去。 接着安装了Adblock Plus，拦截广告还是这个管用！ 因为苹果系统对Flash的不兼容，导致网页上的大部分视频都不能正常观看，看一小会儿就会发热很严重。在百度上搜索“妈妈再也不用担心我的macbook发烫了计划”，它能自动把网页上的Flash格式视频转换成HTML5格式的视频。把这个插件安装上，在进入优酷等对应网页的时候，就可以放心看视频了。 安全性和隐私里面添加“任何来源” 在更新到10.12的系统后，发现在系统偏好设置-\u003e安全性和隐私-\u003e通用里面去掉了“任何来源“选项，导致没有签名的应用没办法安装，只允许AppStore和被认可的开发者的应用可以安装。 在终端输入 sudo spctl --master-disable 命令，就可以重新看到”任何来源“了。 就先配置到这里，差不多可以用了，有啥添加的再看具体情况就可以了。 ","date":"2016-10-14","objectID":"/posts/mac-resetup/:2:0","tags":["Mac","小技巧"],"title":"Mac重装+初始化配置","uri":"/posts/mac-resetup/"},{"categories":["iOS开发"],"content":" 当向一个对象发送消息，如果方法被实现了，则直接在底层使用消息机制调动该方法，如果方法没有被实现，则响应链最前端是《iOS必备技能之Runtime（一）》中提到的动态方法解决方案，如果方法被动态添加，那么这个消息会被对象接收；如果消息不能被接收，则响应链会寻找有没有实现消息转发的方法，让别的类去接收这个消息；如果消息转发也找不到对应的方法实现，那么程序才会报错（unrecognized selector sent to instance）。 ","date":"2016-05-16","objectID":"/posts/runtime-2/:0:0","tags":["iOS","runtime"],"title":"iOS必备技能之Runtime（二）","uri":"/posts/runtime-2/"},{"categories":["iOS开发"],"content":"四、消息转发 消息转发有两种，一种是对消息可定制的，一种是不可定制的。响应链优先响应不可定制的消息转发，如果没有实现就去响应可定制的消息转发。 简单消息转发（不可定制） 简单的消息转发对转发的消息不可以修改，怎么发过来的怎么转走。 - (id)forwardingTargetForSelector:(SEL)aSelector 这个方法赋予实现这个方法的类一个“传球”的能力，如果该类没有实现这个方法，那么forwardingTargetForSelector:返回一个其他类的对象，让其他类里面的方法代为实现。如下示例，该类没有实现method方法，但是转发给OtherClass来实现这个方法。 - (id)forwardingTargetForSelector:(SEL)aSelector { if (aSelector == @selector(method)) { return [[OtherClass alloc] init]; } return [super forwardingTargetForSelector:aSelector]; } 这个方法只能让我们把消息转发到另一个能处理这个消息的对象，但是无法处理消息的内容，比如参数和返回值。 完整消息转发（可定制） 当前面两种方法分别返回NO和nil时，完整的消息转发forwardInvocation:就是保证程序不报“unrecognized selector sent to instance”错误的最后一关了。在完整消息转发里面，forwardInvocation:会对消息进行相应，对象会创建一个NSInvocation对象，把与尚未处理原始消息和参数一起封装起来。 - (void)forwardInvocation:(NSInvocation *)anInvocation 为了理解转发的意图和范围，想象这样一个情景：假使在一个对象里你希望能够响应negotiate 方法，并且其他几个不同类的对象也能够响应这个方法（这几个类实现了negotiate 方法），最先想到的方法应该是直接发送消息到这几个类里面。 进一步思考，假使你的这个对象对negotiate 方法的相应的实现恰恰在其他的类里面，一种实现方法就是让这个对象的类去继承那个类的方法，这样你就可以直接在在这个类里面调用negotiate 方法了。但是，既然他们被分为不同的类，不属于同一继承体系，这也就意味着大部分情况下你往往不能够这么做。 虽然你不能继承negotiate 方法，但是你可以通过把消息直接发送给其他类的对象的方式把这个方法“借”过来。如下： - (id)negotiate { if ( [someOtherObject respondsTo:@selector(negotiate)] ) return [someOtherObject negotiate]; return self; } 但是上面这种处理方式显得有些不灵活，特别是当你想把不止一个消息传递给其他对象的时候——你必须为每一个想要借过来的方法提供和上面类似的实现。另外，如果这些消息本来就是基于runtime的，会随着新的方法和类的改变而改变其实现，那么这种处理方式就变得捉襟见肘了。 forwardInvocation:就能很轻便地解决这个问题，它是这样工作的：当一个对象因为没有消息中对应方法名的方法而不能去响应消息的时候，runtime系统通知这个对象发送forwardInvocation:消息。每一个对象都从NSObject中继承得到forwardInvocation:方法，但是在NSObject的这个方法中只是简单调用了 doesNotRecognizeSelector:，这是个abstract方法（类似于C++的纯虚函数），当子类没有实现这个方法的时候，外部调用这个方法就会抛出异常。 只有当消息的接收者没能调用任何一个该类已经存在的方法的时候，forwardInvocation:方法才能够被调用来处理消息。比如，你想；要你的对象吧negotiate方法转发到其他类的对象，那么它本身就不能有negotiate方法。如果有这个方法，那么该类中就不会调用forwardInvocation:方法。 为了能够转发消息，所有的forwardInvocation:方法必须要做下面两件事： 决定消息要去哪儿 带着原始的参数向目标进行发送 消息可以用invokeWithTarget:来进行发送： - (void)forwardInvocation:(NSInvocation *)anInvocation { if ([someOtherObject respondsToSelector: [anInvocation selector]]) [anInvocation invokeWithTarget:someOtherObject]; else [super forwardInvocation:anInvocation]; } runtime系统首先会调用methodSignatureForSelector:方法来获得方法签名，方法签名记录了方法的参数和返回值的信息。 - (NSMethodSignature*)methodSignatureForSelector:(SEL)selector { NSMethodSignature* signature = [super methodSignatureForSelector:selector]; if (!signature) { signature = [target methodSignatureForSelector:selector]; } return signature; } 转发的消息的返回值是要返回到原始的发送者的，所有的可以返回的类型都能被传递，包括id类型、结构体类型、双精度的浮点型数据等。 一个forwardInvocation:方法可以作为所有未被识别的消息的“分配中心”，把消息打包发送到不同的目标。或者说它可以是一个“换乘站”，把所有的消息发送到同一个目标。它可以把消息进行转化，或者只是简单地“吞掉”它，这样就会没有回应也没有报错。它还可以把几个消息集成到一个响应中。总结起来就是一句话，这个方法能做什么取决去它的实现。 转发和多继承的异同 虽然Objectiv-C不支持多继承，但是使用转发来模仿继承，可以让Objective-C实现一部分多继承的特性。如下图所示，一个对象通过转发来响应消息就像是从其它类里面“借“或者说”继承“一个方法的实现一样。 在上图中，Warrior类把negotiate方法转发到Diplomat类的实例中，就像是Warrior类在实现negotiate方法一样，它会对negotiate方法做出响应。 所以，转发和多继承有很多相似的特点，但是，它们有以下根本的不同之处： 继承是把多种功能集中到了单个的对象中，它使类趋向于巨大化、全能化。相反地，转发是把职责进行了分化，它把一个问题分成了若干小的问题分配给不同的小对象，通过转发进行关联。 respondsToSelector: 、instanceRespondToSelector和isKindOfClass:方法只看继承树，不看转发链，比如[aWarrior respondsToSelector:@selector(negotiate)]在这里为假，即使它能够接收negotiate的消息并且进行响应。\u0010如果使用了协议，那么conformsToProtocol:方法也在此列。但是你可以通过重写这些方法让他在转发中发挥和继承中一样的作用： - (BOOL)respondsToSelector:(SEL)aSelector { if ( [super respondsToSelector:aSelector] ) return YES; else { /* Here, test whether the aSelector message can * * be forwarded to another object and whether that * * object can respond to it. Return YES if it can. */ } return NO; } 这个技巧只适合在没有其他可以使用的方法的情况下使用，它并不可以取代继承的作用。 代理对象 转发不只只是模仿多继承，它尽可能地产生了更轻量化的对象去实现尽可能多的原本属于很多相关对象的特性。代理对象作为其他类的替身，把消息如实传递过去。代理对象更关注的是在向其他类的对象(远程对象)抓发消息这个过程的细节，比如确保在连接远程对象的过程中每个参数被正确传达等。但是它在这个过程中并不是把远程对象做了副本，而是创建了一个对应于远程对象的本地地址，通过这个地址，远程对象在其他应用可以收到这些转发的消息。 还有一种情况，比如你有一个对象需要处理大批量的数据——创建一个复杂的图片或者从本地磁盘中读取文件等，这种情况下使用代理对象也是很合适的。创建一个这样的对象是很耗时的，所以我们希望只有在它确实需要或者在系统资源临时闲置的时候才回去创建它，但是又要保证存在这个对象的占位符使得其他对象涉及到这个对象的时候能够正常运行。 在这种情况下，你可以在最开始的时候不要创建一个全功能的对象，而是创建一个代理对象给它。这个代理对象主要就是为即将创建的大型对象做一个占位，或是在时机成熟的时候，进行消息转发。当代理对象的forwardInvocation：方法第一次被调用的时候，它要确认","date":"2016-05-16","objectID":"/posts/runtime-2/:1:0","tags":["iOS","runtime"],"title":"iOS必备技能之Runtime（二）","uri":"/posts/runtime-2/"},{"categories":["iOS开发"],"content":" Runtime 是一个比较底层的C语言的API，可以翻译为“运行时”。作为使用运行时机制的OC语言的底层，它在程序运行时把OC语言转换成了runtime的C语言代码。学习并理解runtime是OC学习历程中的不可或缺的一大块儿。 ","date":"2016-05-10","objectID":"/posts/runtime-1/:0:0","tags":["iOS","runtime"],"title":"iOS必备技能之Runtime（一）","uri":"/posts/runtime-1/"},{"categories":["iOS开发"],"content":"一、消息机制 调用方法的本质就是发送消息。 发送消息常见的有四个方法： objc_msgSend 向一个类的实例发送消息，返回id类型数据。（这也是最常用的一个发送消息的方法） objc_msgSend_stret 向一个类的实例发送消息，返回结构体类型数据。 objc_msgSendSuper 向一个类的实例的父类发送消息，返回id类型数据。 objc_msgSendSuper_stret 向一个类的实例的父类发送消息，返回结构体类型的数据。 在OC语言中，方法的真正实现是在程序运行的时候绑定的，假如一个方法只有声明，没有实现，调用后在编译阶段是不会出错的，真正报错是在运行的时候。 [receiver message] 以上方法在运行时会被转化为 //receiver是方法的调用者，selector是方法名 objc_msgSend(receiver, selector) //如果有参数 objc_msgSend(receiver, selector, arg1, arg2, ...) 发送消息的原理 objc_msgSend为了完成动态绑定，进行了以下三步： 首先它要先根据方法名找到方法的具体实现程序，因为多态性，同一个方法在不同的类里面可以有不同的实现，所以查找主要依靠寻找receiver所在的类。 传递参数，调用该方法的实现程序。 把该程序的返回值作为方法自己的返回值。 //runtime中对类的定义 struct objc_class { Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; #endif } OBJC2_UNAVAILABLE; //runtime中对实例的定义 struct objc_object { Class isa OBJC_ISA_AVAILABILITY; }; 如上runtime中对类的定义，每一个类都有指向父类的指针(super_class)和一个方法调度表（objc_method_list **methodLists:根据方法名SEL查找该方法的具体实现的地址IMP），当向一个对象发送消息的时候，该对象通过isa指针找到该对象的类(实际上，实例的定义里面也只有这个指针，没有别的了)，在类的调度表查找该方法名，当找不到的时候，通过指向父类的指针找到该类的父类，然后在该类的父类中继续查找该方法名，这样递归查找一直到NSObject类为止(NSProxy类除外，它不属于NSObject子类)。如果查找到该方法名，根据调度表找到该方法的实现的地址进行调用。如下图所示 为了加速发送消息的进程，runtime系统会把使用过的方法名和对应的内存地址缓存起来，每个类都有一个单独的缓存空间，其中包含自己类的方法和继承自父类的方法。在查找调度表之前，runtime系统会首先在缓存中进行查找。 使用隐藏的参数 当objc_msgSend找到方法的实现程序时，它调用这个程序并传递所有方法的参数给它，这其中还包含两个隐藏的参数： 消息的接收对象 调用方法的方法名（selector) 这两个参数虽然没有在方法中进行定义，但是你可以很方便地使用它们。消息的接收对象通过self来引用，方法名通过**_cmd**来引用。 - strange { id target = getTheReceiver(); SEL method = getTheMethod(); if ( target == self || method == _cmd ) return nil; return [target performSelector:method]; } 获取方法的地址 避免动态绑定的唯一方法就是直接获得方法的地址然后把它当做函数一样来调用。当一个方法被连续多次执行，而你又不想每次都用消息机制造成额外的开支，这种办法就是一个合适的使用时机。 下面的例子展示了如何节省开支多次调用setFilled:方法 void (*setter)(id, SEL, BOOL); int i; setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)]; for ( i = 0 ; i \u003c 1000 ; i++ ) setter(targetList[i], @selector(setFilled:), YES); 通过methodForSelector:方法，你可以请求得到指向实现该方法的程序的指针，然后通过这个指针调用该程序。值的注意的是，参数和返回值要正确声明，而且参数中id和SEL要进行显式声明。 ","date":"2016-05-10","objectID":"/posts/runtime-1/:1:0","tags":["iOS","runtime"],"title":"iOS必备技能之Runtime（一）","uri":"/posts/runtime-1/"},{"categories":["iOS开发"],"content":"二、动态方法 假如你想动态地为方法提供实现，OC使用@dynamic实现了这个特性。 @dynamic propertyName; 这样就会通知编译器和这个属性相关的方法将会动态提供。你可以通过方法resolveInstanceMethod:和resolveClassMethod:分别为类方法和实例方法动态地提供实现。 一个OC的方法其实就是由C语言的函数再加上至少两个参数(self和_cmd)组成的。 你可以把一个函数通过class_addMethod作为方法添加到一个类中去。给定以下一个函数： void dynamicMethodIMP(id self, SEL _cmd) { // implementation .... } 你可以通过resolveInstanceMethod:这个方法把上面的函数以方法名(resolveThisMethodDynamically)动态地添加到一个类(MyClass)里面。具体实现方式如下： @implementation MyClass + (BOOL)resolveInstanceMethod:(SEL)aSEL { if (aSEL == @selector(resolveThisMethodDynamically)) { class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, \"v@:\"); return YES; } return [super resolveInstanceMethod:aSEL]; } @end 这其中，class_addMethod这个方法有四个参数，第一个是要添加方法的类，第二个是要添加的方法名，第三个是这个方法的实现函数的指针（值的注意的是，这个函数必须显式地把self和_cmd这两个参数写出来），第四个是方法的参数数组，在这里它是用的类型编码的方式进行表示的，因为方法一定含有self和_cmd这两个参数，所以字符数组的第二个和第三个字符一定是\"@:\",第一个字符代表返回值，这里为空用“v”来表示。相关知识点请见下文。 ","date":"2016-05-10","objectID":"/posts/runtime-1/:2:0","tags":["iOS","runtime"],"title":"iOS必备技能之Runtime（一）","uri":"/posts/runtime-1/"},{"categories":["iOS开发"],"content":"三、类型编码 为了使runtime系统更加简洁，编译器把每个方法的返回值和参数的类型都分别使用一个字符来编码，然后再把它们关联到方法选择器(selector)上。因为这种编码方案在其它环境中也很实用，所以我们可以很方便地使用@encode()编译器指令来自定义类似的编码。 char *buf1 = @encode(int **); char *buf2 = @encode(struct key); char *buf3 = @encode(Rectangle); 一般来说，不管是基本类型，还是指针，或者结构体，或者联合体，甚至可以是类名，只要这个类型能够作为C语言中sizeof()的参数，那么它就能被进行编码。 下表便是已经定义了的类型编码，使用@encode()编译器指令自定义编码的时候一定要避开这些字符。 特别注意，OC不支持long double类型，因此@encode(long double)会返回字符“d\"，意义为double。 结构体的类型编码是按照结构体内部的类型的顺序来表示的，比如 typedef struct example { id anObject; char *aString; int anInt; } Example; 会被编码为： {example=@*i} 由第一章内容可以得知，类的实例的定义是一个只包含isa指针的结构体，所以[NSObject class]会被编码为 { NSObject=# } 具体应用方面，上一章class_addMethod最后一个参数就是使用的类型编码来表示的函数返回值和参数的类型。 参考：《Objective-C Runtime Programing Guide》 链接： iOS必备技能之Runtime（二） 文章会不定期进行增添和更新，欢迎订阅和收藏！ ","date":"2016-05-10","objectID":"/posts/runtime-1/:3:0","tags":["iOS","runtime"],"title":"iOS必备技能之Runtime（一）","uri":"/posts/runtime-1/"},{"categories":null,"content":"Nothing to see here… Move along! ","date":"0001-01-01","objectID":"/projects/:0:0","tags":null,"title":"Projects","uri":"/projects/"}]